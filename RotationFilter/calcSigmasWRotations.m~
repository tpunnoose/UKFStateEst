function X = calcSigmasWRotations(x, P, alpha)
    % calculates the sigma points with multiplicative quaternion update for
    %   q = x(4:7)
    % x - mean estimate of the state
    % P - covariance matrix
    % alpha - weighting coefficient (higher alpha spreads out distribution)
    
    L = numel(x);
    
    X = zeros(L, 2*L);
    
%     lam = eig(P);
    
    A = alpha*chol(P)';
%     try
%         A = alpha*chol(P)';
%     catch
%         % numerical conditioning 
%         P = P + 1e-5 * eye(L);
%         A = alpha*chol(P)';
%     end

    for i=1:L       
        % do simple additive sigma point calculation
        X([1:3 8:13], i) = x([1:3 8:13]) + A([1:3 7:12], i);
        X([1:3 8:13], i+L) = x([1:3 8:13]) - A([1:3 7:12], i);
        
        % do quaternion multiplicative update
        phi = A(4:6,i);
        dq_plus = quatExp(phi);
        dq_neg = quatExp(-phi);
        
        X(4:7, i) = quat_prod(x(4:7), dq_plus);
        X(4:7, i+L) = quat_prod(x(4:7), dq_neg);
    end
   
end

function q = quatExp(phi)
% turn rotation vector into quaternion 

q = zeros(4,1);
mag = norm(phi);

if mag ~= 0
    q(1) = cos(0.5*mag);
    q(2:4) = sin(0.5*mag) * phi/mag;
end
end